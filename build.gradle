import java.util.regex.Pattern
import java.util.regex.Matcher

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'com.mapvine:gradle-cobertura-plugin:1.0'
        classpath 'com.ullink.gradle:gradle-repositories-plugin:1.1-SNAPSHOT' //https://github.com/gluck/gradle-repositories-plugin
        classpath 'nl.javadude.gradle.plugins:license-gradle-plugin:0.6.0'  //https://github.com/hierynomus/license-gradle-plugin
    }
}

apply plugin: 'cobertura'
apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin: 'jetty'
apply plugin: 'maven'
apply plugin: 'project-report'
apply plugin: 'repositories'
apply plugin: 'license'

group = 'org.kar'
// http://stackoverflow.com/questions/8958267/java-lang-verifyerror-expecting-a-stackmap-frame
sourceCompatibility = 1.6
targetCompatibility = 1.6

repositories {
    mavenCentral()
    maven { url 'http://static.appfuse.org/repository' }
    maven { url 'https://repository.jboss.org/nexus/content/repositories/releases' }
    maven { url 'http://maven.restlet.org' }
    googlecode('groovy-restlet') // http://groovy-restlet.googlecode.com/files/groovy-restlet-0.3-SNAPSHOT.jar
}

idea {
    module {
        downloadJavadoc = true
        downloadSources = true
        inheritOutputDirs = false
        outputDir = sourceSets.main.output.classesDir
        testOutputDir = sourceSets.test.output.classesDir
    }
}

ext.versions = [
        'groovy': '2.0.5',
        'jsp': '2.1',
        'junit': '4.10',
        'servlet': '2.5',
        'jstl': '1.2',
        'slf4j': '1.6.1',
        'log4j': '1.2.16',
        'spock': '0.7-groovy-2.0',
        'hsqldb': '2.2.8',
        'cglib': '2.2.2'
]

dependencies {
    providedCompile "javax.servlet.jsp:jsp-api:${versions.jsp}"
    providedCompile "javax.servlet:servlet-api:${versions.servlet}"
    providedCompile "javax.servlet:jstl:${versions.jstl}"

    groovy "org.codehaus.groovy:groovy-all:${versions.groovy}"
    compile "org.slf4j:slf4j-api:${versions.slf4j}"
    compile "log4j:log4j:${versions.log4j}"

    compile('org.codehaus.groovy.modules.http-builder:http-builder:0.5.2') {
        exclude module: 'groovy'
    }

    compile 'groovy-restlet:groovy-restlet:0.3-SNAPSHOT'
//    compile 'org.restlet.jse:org.restlet:2.1.0' // not compatible with groovy-restlet unfortunately
    compile 'org.restlet:org.restlet:1.1.10'
    compile 'org.springframework:spring-context:2.5.6'
    compile 'com.noelios.restlet:com.noelios.restlet:1.1.10'

    runtime "org.slf4j:jcl-over-slf4j:${versions.slf4j}"
    runtime "org.slf4j:slf4j-log4j12:${versions.slf4j}"
    runtime "org.hsqldb:hsqldb:${versions.hsqldb}"

    testCompile 'org.vert-x:vertx-lang-groovy:1.2.3.final'
    testCompile "junit:junit:${versions.junit}"
    testCompile "org.spockframework:spock-core:${versions.spock}"
    testCompile 'org.eclipse.jetty.aggregate:jetty-all-server:8.1.0.v20120127'    // this one works !
//    testCompile 'org.eclipse.jetty.aggregate:jetty-all-server:8.1.4.v20120524'    //java.lang.SecurityException
//    testCompile 'org.eclipse.jetty.aggregate:jetty-all-server:8.1.5.v20120716'    //java.lang.SecurityException
//    testCompile 'org.eclipse.jetty.aggregate:jetty-all-server:8.1.3.v20120416'    //java.lang.SecurityException
//    testCompile 'org.eclipse.jetty.aggregate:jetty-all-server:8.1.2.v20120308'    //java.lang.SecurityException
//    testCompile 'org.eclipse.jetty.aggregate:jetty-all-server:8.1.1.v20120215'    //java.lang.SecurityException

}

[jettyRun, jettyRunWar]*.httpPort = 8081
[jettyRun, jettyRunWar, jettyStop]*.stopPort = 8082
[jettyRun, jettyRunWar, jettyStop]*.stopKey = 'stopKey'

test {
    jvmArgs '-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005'
    doFirst {
        jettyRun.daemon = true
        jettyRun.execute()
    }
    doLast {
        jettyStop.execute()
    }
    systemProperty 'httpPort', jettyRun.httpPort
    systemProperty 'appName', project.name
}

jettyRun {
    scanIntervalSeconds = 1
}

license {
    header rootProject.file('LICENSE.txt')
}

defaultTasks 'jettyRun'

task wrapper(type: Wrapper) {
    gradleVersion = '1.3'
}

task extractSnippets(type: ExtractSnippetsTask) {
    source sourceSets.test.allSource, sourceSets.main.allSource, file('src/main/webapp'), file('jettyStarter.groovy')
    snippetsDir = file("$buildDir/snippets")
}

/**
 * Produces the snippets files for a set of sample source files.
 */
public class ExtractSnippetsTask extends SourceTask {
    @OutputDirectory
    File snippetsDir

    final Pattern START_XML = Pattern.compile('\\s*<!--\\s*START\\s+SNIPPET\\s+(\\S+)\\s*-->')
    final Pattern END_XML = Pattern.compile('\\s*<!--\\s*END\\s+SNIPPET\\s+(\\S+)\\s*-->')
    final Pattern START_ANY = Pattern.compile('\\s*//\\s*START\\s+SNIPPET\\s+(\\S+)\\s*')
    final Pattern END_ANY = Pattern.compile('\\s*//\\s*END\\s+SNIPPET\\s+(\\S+)\\s*')

    @TaskAction
    def extract() {
        source.visit { FileVisitDetails details ->
            String name = details.relativePath.pathString
            if (!details.file.isDirectory()) {
                File srcFile = details.file
                Map writers = [:]
                Pattern startSnippetPattern
                Pattern endSnippetPattern
                if (name.endsWith('.xml')) {
                    startSnippetPattern = START_XML
                    endSnippetPattern = END_XML
                } else {
                    startSnippetPattern = START_ANY
                    endSnippetPattern = END_ANY
                }

                try {
                    // Can't use eachLine {} because it throws away blank lines
                    srcFile.withReader {Reader r ->
                        BufferedReader reader = new BufferedReader(r)

                        reader.readLines().each {String line ->
                            Matcher m = startSnippetPattern.matcher(line)
                            if (m.matches()) {
                                String snippetName = m.group(1)
                                String subDirName
                                File subDir
                                if(snippetName.contains('::')){
                                    (subDirName, snippetName) = snippetName.split('::')
                                }
                                if(subDirName)
                                {
                                    subDir = new File(snippetsDir, subDirName)
                                    subDir.mkdirs()
                                }
                                if (!writers[snippetName]) {
                                    File snippetFile = new File(subDir ?: snippetsDir, snippetName)
                                    writers.put(snippetName, new SnippetWriter("Snippet $snippetName in $name", snippetFile))
                                }
                                writers[snippetName].start()
                                return
                            }
                            m = endSnippetPattern.matcher(line)
                            if (m.matches()) {
                                String snippetName = m.group(1)
                                writers[snippetName].end()
                                return
                            }
                            writers.values().each {SnippetWriter w ->
                                w.println(line)
                            }
                        }
                    }
                } finally {
                    writers.values().each {SnippetWriter w ->
                        w.close()
                    }
                }
            }
        }
    }
}

class SnippetWriter {

    private final File dest
    private final String displayName
    private boolean appendToFile
    private Writer writer
    private static int minIndent

    def SnippetWriter(String displayName, File dest) {
        this.dest = dest
        this.displayName = displayName
    }

    def start() {
        if (writer) {
            throw new RuntimeException("$displayName is already started.")
        }
        dest.parentFile.mkdirs()
        writer = new StringWriter()
        appendToFile = true
        this
    }

    def println(String line) {
        if (writer) {
            writer.println(line)
        }
    }

    def end() {
        if (!writer) {
            throw new RuntimeException("$displayName was not started.")
        }
        dest.withWriter {Writer w ->
            w.append(writer.toString().stripIndent())
        }
        close()
    }

    def close() {
        if (writer) {
            writer.close()
        }
        writer = null
    }
}